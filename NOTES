Connecting hosts
================

hosts can connect mutually (host A connected to host B, and host B
connected to host A) or multiply (host A connected to host B more than
1 time), and each connection will have it's own 'peer' in hosts A and
B


**Channels**

a "client" host can communicate bi-directionally on as many channels as
a "server" host supports

SCENARIO 1

host A has 2 channels
host B has 4 channels

host A requests to connect to host B with 6 channels

- this returns a (not-connected) peer with channelCount of 6
- when the connected event is received by A, the peer channelCount
  will be set to 4
- host B receives the request to connect from host A the connected A
  peer will have 4 channels

==> A and B can communicate bi-directionally on 4 channels


SCENARIO 2

host A has 4 channels
host B has 2 channels

host A requests to connect to host B with 6 channels

- this returns a (not-connected) B peer with channelCount of 6
- when the connected event is received by A, the B peer channelCount
  will be set to 2
- host B receives the request to connect from host A the connected
  A peer will have 2 channels

==> A and B can communicate bi-directionally on 2 channels


Sending Packets
===============

- int enet_peer_send (peer, channelID, packet):

  no error is generated for a host sending to a peer where the
  channelID is greater than the host channelLimit; however the
  function *does* return an error if the channelID exceeds the
  peer's channelCount

  errors (return -1):

  * peer->channelCount <= channelID
  * peer->state != CONNECTED
  * peer->host.maximumPacketLength < packet.dataLength

  * either:
    1. (internal variable) fragmentLength < packet.dataLength, and
      either:

      a. ENET_PROTOCOL_MAXIMUM_FRAGMENT_COUNT < fragmentCount (internal variable)

      or

      b. outgoing command fragment malloc failure

  * or: outgoing command malloc failure

the first 3 and a. should be detectable before calling the low-level
send function, leaving only malloc failure in which case no
ENetOutgoingCommands will be "queued" (no fragments) or "setup"
(fragments). i'm assuming at this point the packet will still be
destroyed automatically (???)

- void enet_host_broadcast (host, channelID, packet):

  does not check host for host's channelLimit < channelID, but will
  silently fail when calling enet_peer_send for each connected peer
  where peer.channelCount <= channelID

  enet_host_broadcast iterates over each *allocated*
  peer, that is, the peerCount requested when the host was created
  but will check for connection status and not call send for
  non-connected peers


*Client vs. Server*

servers are allowed to connect to eachother, therefore in the
low-level library a server is not enforced to only accept connections,
but a client will never accept connections

if a host "server" only ever accepts connections, then no packets
will ever successfuly send or broadcast if host.channelLimit <=
channelID

for a host "client", a connection with a server can use as many
channels as the server allows, so host.channelLimit is not used in
this case
